
数据是为了获取信息，所以我们要处理数据
因为我们要从数据中获得信息

计算机只认识0和1

区分
110 和 1 10
6          1  2
限定位宽就可以区分了
0000 0000 0000 0000 0000 0000 0000 0001 
0···110  6
0····01| 00···10  1 | 2
整数占4位字节
1个字节可以看作一个车厢
1Byte=8bits
1个字节一共可以表示2^7-1个数
1000,0000 后面几个零就是几次方
整数可以表示2^31-1个数

当0111,1111再加1时
变成1000,0000

执行结果就是原原本本输出电脑输出上的内容

知道数据类型是为了给内存分配空间

存储的基本原理
1
-1      最高位加入符号位

计算机处理思路 根据数据的位数，看有多少位

单目双目 操作数有几个
也就是运算对象
什么类型的数据类型作运算结果也是什么数据类型
整型相除小数直接去掉

++i是先执行i=i+1 再使用i的值（赋值等）
i++是先用i的值（赋值等） 再执行i=i+1

（++、--、-）单目优先级最高->（*、/、%）->（+、-）
单目高于双目
混合运算
优先级相同的时候 结合方向按自左向右

关系表达式：关系表达式返回的是布尔型
关系运算符低于算术运算符，高于赋值运算符，括号是最高优先级的
大/小于运算符优先级高于等于运算符
关系运算符高于赋值运算符

a=b>c 计算的值赋给a 等效于a=(b>c)
a=3,b=2,c=1
f=a>b>c 先算a>b得1（因为是真）再算1>c 得0 所以f=0
非运算符（！）->算术运算符->关系运算符->与（&&）->或（||）运算符->赋值运算符

逻辑运算符和逻辑表达式
优先级：!->&&->|| (！高于算术运算符)
0是假 其他都是真

并不是所有逻辑运算符都被执行
a && b && c 当a为真，才需要判断b的值 a && b为真才要判c
如果a为假 直接输出假
或同理 有一个真直接输出真
&&中有一个假就是假，||有一个真就是真

```c
if(x++>0 && b<x++)
若x++>0 为假，则b<x++ 不执行
if(x++>0 && b<x++)
若x++>0 为真，则b<x++ 不执行
其他情况都执行
```

数据溢出的原因
如何方便安全使用计算机内存？用变量（控制了给计算机申请多大的内存，变量使用之前要定义，也就是变量就是给电脑知道我要给你多少内存来使用）
结构体（把不同数据类型放在一起）、数组（连续分配几个连续空间）

计算机存储的原理
把记忆性的东西记住之后再去掌握本质和**原理**，深入去学习

数值表示方法——原码反码补码
补码的好处：解决原码再正负数的数值不同
如果相同的数字比如0 但这样就会分为+0 -0
采用补码后方便正负号数据运算，符合位可以直接参与运算

当用short型存储数据时，存到32767再+1时 就是理解为补码（补码跟符号位一起算进去了）得的就是-32768

发生溢出往往是数据从正数变为负数
要考虑把多大的数放进去

浮点数的存储的数值很大，为什么？

赋值运算符本质就是将信息存入内存中
x*=y+8 这里如果有若干表达式相当于是有括号运算

赋值表达式是将表达式的值赋给变量
赋值运算符左侧是一个可修改的“左值”（左值就是存储空间，应可以被赋值）
赋值运算符右侧是一个表达式称为“右值”
赋值运算符是自右往左结合

浮点型赋值给整型的时候，浮点数取整（直接舍弃小数部分）
整型赋值给浮点数的时候，数值不变，直接转换数据类型
一个long int 赋值给 int时只将低字节直接赋给变量
经可能保存多的数据

附加字符%m.nd
m: 数据宽度
n: 对实数，表示输出多少位小数(会四舍五入)，对字符串 截取几个字符

条件表达式
优先级：高于赋值，低于逻辑、关系、算术运算符
结合方向：自右向左
交换两个数要借助中间变量

画流程图对程序进行优化
把重复的进行优化
scanf输入是输入到名字里面 （京东购物输入地址）
1234*5678*0 会直接把0放到前面算变成0*1234*5678 后面1234*5678不计算
有限状态转移方程
交通信号灯

if(!x)等价于
if(x==0||x=='\0')；

if(x)等价于

if(x!=0||!x==0)。

switch-case会一直往下执行直到遇到break（包括default）
